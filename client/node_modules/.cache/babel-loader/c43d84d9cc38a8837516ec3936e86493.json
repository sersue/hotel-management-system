{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Tokenize input string.\n */\n\nfunction lexer(str) {\n  var tokens = [];\n  var i = 0;\n\n  while (i < str.length) {\n    var char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({\n        type: \"MODIFIER\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({\n        type: \"ESCAPED_CHAR\",\n        index: i++,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({\n        type: \"OPEN\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({\n        type: \"CLOSE\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \":\") {\n      var name = \"\";\n      var j = i + 1;\n\n      while (j < str.length) {\n        var code = str.charCodeAt(j);\n\n        if ( // `0-9`\n        code >= 48 && code <= 57 || // `A-Z`\n        code >= 65 && code <= 90 || // `a-z`\n        code >= 97 && code <= 122 || // `_`\n        code === 95) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(\"Missing parameter name at \" + i);\n      tokens.push({\n        type: \"NAME\",\n        index: i,\n        value: name\n      });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      var count = 1;\n      var pattern = \"\";\n      var j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(\"Capturing groups are not allowed at \" + j);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(\"Unbalanced pattern at \" + i);\n      if (!pattern) throw new TypeError(\"Missing pattern at \" + i);\n      tokens.push({\n        type: \"PATTERN\",\n        index: i,\n        value: pattern\n      });\n      i = j;\n      continue;\n    }\n\n    tokens.push({\n      type: \"CHAR\",\n      index: i,\n      value: str[i++]\n    });\n  }\n\n  tokens.push({\n    type: \"END\",\n    index: i,\n    value: \"\"\n  });\n  return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\n\n\nfunction parse(str, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var tokens = lexer(str);\n  var _a = options.prefixes,\n      prefixes = _a === void 0 ? \"./\" : _a;\n  var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n  var result = [];\n  var key = 0;\n  var i = 0;\n  var path = \"\";\n\n  var tryConsume = function (type) {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  var mustConsume = function (type) {\n    var value = tryConsume(type);\n    if (value !== undefined) return value;\n    var _a = tokens[i],\n        nextType = _a.type,\n        index = _a.index;\n    throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n  };\n\n  var consumeText = function () {\n    var result = \"\";\n    var value; // tslint:disable-next-line\n\n    while (value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\")) {\n      result += value;\n    }\n\n    return result;\n  };\n\n  while (i < tokens.length) {\n    var char = tryConsume(\"CHAR\");\n    var name = tryConsume(\"NAME\");\n    var pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      var prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix: prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n\n    var value = char || tryConsume(\"ESCAPED_CHAR\");\n\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    var open = tryConsume(\"OPEN\");\n\n    if (open) {\n      var prefix = consumeText();\n      var name_1 = tryConsume(\"NAME\") || \"\";\n      var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n      var suffix = consumeText();\n      mustConsume(\"CLOSE\");\n      result.push({\n        name: name_1 || (pattern_1 ? key++ : \"\"),\n        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n        prefix: prefix,\n        suffix: suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\n\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options), options);\n}\n\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\n\nfunction tokensToFunction(tokens, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var reFlags = flags(options);\n  var _a = options.encode,\n      encode = _a === void 0 ? function (x) {\n    return x;\n  } : _a,\n      _b = options.validate,\n      validate = _b === void 0 ? true : _b; // Compile all the tokens into regexps.\n\n  var matches = tokens.map(function (token) {\n    if (typeof token === \"object\") {\n      return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n    }\n  });\n  return function (data) {\n    var path = \"\";\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      var value = data ? data[token.name] : undefined;\n      var optional = token.modifier === \"?\" || token.modifier === \"*\";\n      var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n          throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          var segment = encode(value[j], token);\n\n          if (validate && !matches[i].test(segment)) {\n            throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        var segment = encode(String(value), token);\n\n        if (validate && !matches[i].test(segment)) {\n          throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n      var typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n    }\n\n    return path;\n  };\n}\n\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\n\nfunction match(str, options) {\n  var keys = [];\n  var re = pathToRegexp(str, keys, options);\n  return regexpToFunction(re, keys, options);\n}\n\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\n\nfunction regexpToFunction(re, keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.decode,\n      decode = _a === void 0 ? function (x) {\n    return x;\n  } : _a;\n  return function (pathname) {\n    var m = re.exec(pathname);\n    if (!m) return false;\n    var path = m[0],\n        index = m.index;\n    var params = Object.create(null);\n\n    var _loop_1 = function (i) {\n      // tslint:disable-next-line\n      if (m[i] === undefined) return \"continue\";\n      var key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    };\n\n    for (var i = 1; i < m.length; i++) {\n      _loop_1(i);\n    }\n\n    return {\n      path: path,\n      index: index,\n      params: params\n    };\n  };\n}\n\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\n\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\n\n\nfunction flags(options) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\n\n\nfunction regexpToRegexp(path, keys) {\n  if (!keys) return path; // Use a negative lookahead to match only capturing groups.\n\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: \"\",\n        suffix: \"\",\n        modifier: \"\",\n        pattern: \"\"\n      });\n    }\n  }\n\n  return path;\n}\n/**\n * Transform an array into a regexp.\n */\n\n\nfunction arrayToRegexp(paths, keys, options) {\n  var parts = paths.map(function (path) {\n    return pathToRegexp(path, keys, options).source;\n  });\n  return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\n\n\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\n\n\nfunction tokensToRegexp(tokens, keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.strict,\n      strict = _a === void 0 ? false : _a,\n      _b = options.start,\n      start = _b === void 0 ? true : _b,\n      _c = options.end,\n      end = _c === void 0 ? true : _c,\n      _d = options.encode,\n      encode = _d === void 0 ? function (x) {\n    return x;\n  } : _d;\n  var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n  var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n  var route = start ? \"^\" : \"\"; // Iterate over the tokens and create our regexp string.\n\n  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n    var token = tokens_1[_i];\n\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      var prefix = escapeString(encode(token.prefix));\n      var suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            var mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n          } else {\n            route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n          }\n        } else {\n          route += \"(\" + token.pattern + \")\" + token.modifier;\n        }\n      } else {\n        route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += delimiter + \"?\";\n    route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n  } else {\n    var endToken = tokens[tokens.length - 1];\n    var isEndDelimited = typeof endToken === \"string\" ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 : // tslint:disable-next-line\n    endToken === undefined;\n\n    if (!strict) {\n      route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n    }\n\n    if (!isEndDelimited) {\n      route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\n\nfunction pathToRegexp(path, keys, options) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n\nexports.pathToRegexp = pathToRegexp;","map":{"version":3,"sources":["/Users/chunghojung/Desktop/hotel-management-system/client/node_modules/next/dist/compiled/path-to-regexp/index.js"],"names":["Object","defineProperty","exports","value","lexer","str","tokens","i","length","char","push","type","index","name","j","code","charCodeAt","TypeError","count","pattern","parse","options","_a","prefixes","defaultPattern","escapeString","delimiter","result","key","path","tryConsume","mustConsume","undefined","nextType","consumeText","prefix","indexOf","suffix","modifier","open","name_1","pattern_1","compile","tokensToFunction","reFlags","flags","encode","x","_b","validate","matches","map","token","RegExp","data","optional","repeat","Array","isArray","segment","test","String","typeOfMessage","match","keys","re","pathToRegexp","regexpToFunction","decode","pathname","m","exec","params","create","_loop_1","split","replace","sensitive","regexpToRegexp","groups","source","arrayToRegexp","paths","parts","join","stringToRegexp","tokensToRegexp","strict","start","_c","end","_d","endsWith","route","_i","tokens_1","mod","endToken","isEndDelimited"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \" + i);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \" + j);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \" + i);\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \" + i);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: \"\",\n                suffix: \"\",\n                modifier: \"\",\n                pattern: \"\"\n            });\n        }\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n    var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n                    }\n                    else {\n                        route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n                    }\n                }\n                else {\n                    route += \"(\" + token.pattern + \")\" + token.modifier;\n                }\n            }\n            else {\n                route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += delimiter + \"?\";\n        route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\nexports.pathToRegexp = pathToRegexp;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}